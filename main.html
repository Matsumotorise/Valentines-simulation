<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Valentine's - Synced & Sculpted</title>
    <style>
        body {
            margin: 0;
            background-color: #000005;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 380px;
            z-index: 10;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .panel {
            background: rgba(20, 5, 10, 0.85);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 100, 100, 0.2);
            box-shadow: 0 0 60px rgba(255, 0, 50, 0.15);
            text-align: center;
            pointer-events: auto;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 10px;
            opacity: 0.6;
            margin-bottom: 5px;
            text-align: left;
            letter-spacing: 1px;
            color: #fba;
        }

        select {
            width: 100%;
            background: #050202;
            color: #fce;
            border: 1px solid #522;
            padding: 12px;
            border-radius: 8px;
            font-family: inherit;
            outline: none;
            font-size: 11px;
            cursor: pointer;
        }

        button {
            width: 100%;
            background: linear-gradient(135deg, #fcc, #f66);
            color: #400;
            border: none;
            padding: 16px;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.4);
            transition: transform 0.1s;
        }

        button:active { transform: scale(0.97); }

        .hidden { opacity: 0; pointer-events: none; }

        .hint {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            opacity: 0.6;
            letter-spacing: 4px;
            pointer-events: none;
            color: #fba;
            text-transform: uppercase;
        }
    </style>
</head>
<body>

    <div class="hint">Scroll to Zoom â€¢ Drag to Inspect</div>
    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div class="panel">
            <div class="controls-grid">
                <div>
                    <label>ASSEMBLY MODE</label>
                    <select id="algoSelect">
                        <option value="implode" selected>Radial (Implode)</option>
                        <option value="scan">Scan (Bottom-Up)</option>
                        <option value="slice">Slice (Left-Right)</option>
                        <option value="spiral">Spiral (Center-Out)</option>
                        <option value="stripes">Radix (Stripes)</option>
                        <option value="blocks">Grid Blocks</option>
                        <option value="chaos">Bogo (Random)</option>
                    </select>
                </div>
                <div>
                    <label>TIMING</label>
                    <select id="speedSelect">
                        <option value="slow" selected>Cinematic (Slow)</option>
                        <option value="normal">Normal</option>
                        <option value="fast">Fast</option>
                    </select>
                </div>
            </div>
            <button id="btnStart">INITIATE COLLISION</button>
        </div>
    </div>

<script>
    // --- AUDIO ENGINE ---
    const SoundFX = {
        ctx: null, heartbeatInterval: null,
        init: function() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        },
        playSwoosh: function(durationMS) {
            if (!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * (durationMS / 1000);
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522; b5 = -0.7616 * b5 - white * 0.0168980;
                data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                b6 = white * 0.115926;
            }
            const noise = this.ctx.createBufferSource(); noise.buffer = buffer;
            const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.Q.value = 1;
            const now = this.ctx.currentTime; const dur = durationMS / 1000;
            filter.frequency.setValueAtTime(100, now);
            filter.frequency.exponentialRampToValueAtTime(3000, now + dur/2);
            filter.frequency.exponentialRampToValueAtTime(100, now + dur);
            const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.3, now + dur/2); gain.gain.linearRampToValueAtTime(0, now + dur);
            noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            noise.start();
        },
        playImpact: function() {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.5, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
            osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + 0.3);
        },
        startHeartbeat: function() {
            if (!this.ctx || this.heartbeatInterval) return;
            this.heartbeatInterval = setInterval(() => {
                if (this.ctx.state === 'suspended') return;
                const playBeat = (delay, freq) => {
                    const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime + delay);
                    osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + 0.15);
                    gain.gain.setValueAtTime(0, this.ctx.currentTime + delay);
                    gain.gain.linearRampToValueAtTime(3.0, this.ctx.currentTime + delay + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + delay + 0.2);
                    osc.connect(gain); gain.connect(this.ctx.destination);
                    osc.start(this.ctx.currentTime + delay); osc.stop(this.ctx.currentTime + delay + 0.2);
                };
                playBeat(0, 50);      // Lub
                playBeat(0.25, 65);   // Dub
            }, 2094);
        }
    };

    // --- VISUAL ENGINE ---
    const CONFIG = {
        HEART_COUNT: 2000, HEART_SIZE: 600,
        RING_1_COUNT: 4000, RING_1_INNER: 900, RING_1_OUTER: 1300, 
        RING_2_COUNT: 4000, RING_2_INNER: 1300, RING_2_OUTER: 1700,
        DUST_COUNT: 3000, PERSPECTIVE: 800,
        ORBIT_DISTANCE: -7800, FINAL_DISTANCE: -6500, BASE_TILT: 0.5, START_X: 2000, 
        MAX_ZOOM: -14000 
    };

    const TIMING = {
        slow: { approachMS: 8000, explodeMS: 4000, sortSpeed: 10, camSpeed: 0.001 },
        normal: { approachMS: 4000, explodeMS: 2000, sortSpeed: 40, camSpeed: 0.003 },
        fast: { approachMS: 2000, explodeMS: 1000, sortSpeed: 120, camSpeed: 0.006 }
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const uiLayer = document.getElementById('ui-layer');
    const btnStart = document.getElementById('btnStart');

    const STATE = { STAR: 0, APPROACH: 1, COLLISION: 2, SORTING: 3, LOVE_APPROACH: 4, LOVE_EXPLODE: 5, LOVE_WAIT: 6, LOVE_FORM: 7, DONE: 8 };
    let currentState = STATE.STAR; let stateStartTime = 0;
    let width, height; 
    let particles = []; 
    let textParticles = []; 
    let dustParticles = []; 
    let sortIndex = 0; let camShake = 0;
    let camOrbitAngle = 0; let camTiltAngle = CONFIG.BASE_TILT; let camDistance = CONFIG.ORBIT_DISTANCE; let targetCamDistance = CONFIG.ORBIT_DISTANCE;
    let currentSettings = TIMING.slow;
    let ring1Angle = 0; let ring2Angle = 0; let dustAngle = 0; let heartAngle = 0; 
    let autoRotate = true; let isDragging = false; let lastX = 0, lastY = 0; let resumeTimeout; let lastTap = 0;

    function getTextPoints() {
        const tCanvas = document.createElement('canvas'); const tCtx = tCanvas.getContext('2d');
        tCanvas.width = 1000; tCanvas.height = 300;
        tCtx.fillStyle = 'white'; tCtx.font = 'bold 140px "Courier New"'; tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle';
        tCtx.fillText('Love you bb', 500, 150);
        const imageData = tCtx.getImageData(0, 0, 1000, 300); const data = imageData.data; const points = [];
        for(let y = 0; y < 300; y += 6) {
            for(let x = 0; x < 1000; x += 6) {
                if(data[(y * 1000 + x) * 4 + 3] > 128) points.push({ x: ((x - 500) * 2.5) + (Math.random() - 0.5) * 8, y: ((y - 150) * 2.5 - 900) + (Math.random() - 0.5) * 8 });
            }
        }
        return points;
    }

    function getHeartTarget(scale) {
        const theta = Math.random() * Math.PI * 2; 
        const phi = Math.acos(2 * Math.random() - 1);
        const dx = Math.sin(phi) * Math.cos(theta);
        const dy = Math.sin(phi) * Math.sin(theta);
        const dz = Math.cos(phi);
        
        let r = 0.1;
        for (let i = 0; i < 150; i++) {
            let x = dx * r; let y = dy * r; let z = dz * r;
            let val = Math.pow(x*x + (9/4)*y*y + z*z - 1, 3) - x*x*z*z*z - (9/80)*y*y*z*z*z;
            if (val > 0.0) {
                return { x: x * scale, y: -z * scale, z: y * scale };
            }
            r += 0.02;
        }
        return { x: 0, y: 0, z: 0 };
    }

    function getSpherePoint(radius) {
        const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
        const r = radius * Math.cbrt(Math.random());
        return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
    }

    function getFinalColor(dist, maxDist, type) {
        const ratio = Math.min(1, dist / maxDist);
        if (type === 'heart') return { h: 340 - ratio * 20, s: '100%', l: 75 + (1-ratio) * 20 };
        else if (type === 'ring1') return { h: 190 + Math.random()*20, s: '100%', l: 80 };
        else if (type === 'ring2') return { h: 280 + Math.random()*30, s: '100%', l: 80 };
        else if (type === 'text') return { h: 350, s: '100%', l: 60 }; 
        else return { h: 0, s: '0%', l: 100 };
    }

    function init() {
        width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight;
        particles = []; textParticles = []; dustParticles = [];
        let teamToggle = false;
        
        const createParticle = (type, tx, ty, tz, size, baseRadiusForColor, layerIndex = -1) => {
            const finalC = getFinalColor(Math.sqrt(tx**2 + ty**2 + tz**2), baseRadiusForColor, type);
            teamToggle = !teamToggle;
            
            const startOffset = getSpherePoint(300); 
            const p = {
                type: type, layerIndex: layerIndex, startTeam: teamToggle ? 'blue' : 'purple',
                lx: startOffset.x, ly: startOffset.y, lz: startOffset.z,
                x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0,
                tx: tx, ty: ty, tz: tz, hue: finalC.h, sat: finalC.s, light: finalC.l, size: size, active: false
            };
            
            if (type === 'dust') dustParticles.push(p);
            else particles.push(p);
        };

        for (let i = 0; i < CONFIG.HEART_COUNT; i++) {
            const t = getHeartTarget(CONFIG.HEART_SIZE);
            createParticle('heart', t.x, t.y, t.z, 3.0, CONFIG.HEART_SIZE); 
        }
        for (let i = 0; i < CONFIG.RING_1_COUNT; i++) { const a = Math.random() * Math.PI * 2; const r = CONFIG.RING_1_INNER + Math.random() * (CONFIG.RING_1_OUTER - CONFIG.RING_1_INNER); createParticle('ring1', r * Math.cos(a), (Math.random() - 0.5) * 50, r * Math.sin(a), 2.5, CONFIG.RING_1_OUTER); }
        for (let i = 0; i < CONFIG.RING_2_COUNT; i++) { const a = Math.random() * Math.PI * 2; const r = CONFIG.RING_2_INNER + Math.random() * (CONFIG.RING_2_OUTER - CONFIG.RING_2_INNER); createParticle('ring2', r * Math.cos(a), (Math.random() - 0.5) * 50, r * Math.sin(a), 2.2, CONFIG.RING_2_OUTER); }
        for (let i = 0; i < CONFIG.DUST_COUNT; i++) createParticle('dust', 0, 0, 0, 2.0 + Math.random() * 2, 0); 

        getTextPoints().forEach(pt => {
            const offset = getSpherePoint(150);
            textParticles.push({
                type: 'text', lx: offset.x, ly: offset.y, lz: offset.z, x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0,
                tx: pt.x, ty: pt.y, tz: 0, hue: 350, sat: '90%', light: 60, size: 3.5 + Math.random() * 2.5, active: false
            });
        });
    }

    function triggerStart() {
        if (currentState !== STATE.STAR) return;
        SoundFX.init(); 
        uiLayer.classList.add('hidden'); setTimeout(() => { uiLayer.style.display = 'none'; }, 500);
        
        const speedVal = document.getElementById('speedSelect').value; currentSettings = TIMING[speedVal];
        currentState = STATE.APPROACH; stateStartTime = performance.now(); SoundFX.playSwoosh(currentSettings.approachMS);
        
        setTimeout(() => {
            currentState = STATE.COLLISION; SoundFX.playImpact(); 
            const explodeForce = speedVal === 'slow' ? 150 : 500; camShake = 50;
            
            const applyExplosion = p => {
                const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                let speed;
                if (p.type === 'dust') {
                    speed = explodeForce * (1.0 + Math.random() * 2.5); 
                    p.x = 0; p.y = 0; p.z = 0; 
                } else {
                    speed = explodeForce * (0.5 + Math.random() * 1.5); 
                    p.x = (p.startTeam === 'blue' ? 0.1 : -0.1) + p.lx; p.y = p.ly; p.z = p.lz;
                }
                
                p.vx = speed * Math.sin(phi) * Math.cos(theta);
                p.vy = speed * Math.sin(phi) * Math.sin(theta);
                p.vz = speed * Math.cos(phi);
            };

            particles.forEach(applyExplosion);
            dustParticles.forEach(applyExplosion);

            setTimeout(() => {
                const algo = document.getElementById('algoSelect').value;
                if (algo === 'scan') particles.sort((a, b) => a.ty - b.ty);
                else if (algo === 'slice') particles.sort((a, b) => a.tx - b.tx);
                else if (algo === 'spiral') particles.sort((a, b) => Math.atan2(a.tx, a.tz) - Math.atan2(b.tx, b.tz));
                else if (algo === 'implode') particles.sort((a, b) => (a.tx**2+a.ty**2+a.tz**2) - (b.tx**2+b.ty**2+b.tz**2));
                else if (algo === 'stripes') particles.sort((a, b) => (Math.floor(a.ty/60)%2 - Math.floor(b.ty/60)%2));
                else if (algo === 'blocks') particles.sort((a, b) => (Math.floor(a.tx/100) + Math.floor(a.ty/100)) - (Math.floor(b.tx/100) + Math.floor(b.ty/100)));
                else particles.sort(() => Math.random() - 0.5);
                
                currentState = STATE.SORTING; targetCamDistance = CONFIG.FINAL_DISTANCE;
            }, currentSettings.explodeMS);
        }, currentSettings.approachMS);
    }

    window.addEventListener('wheel', (e) => {
        if (e.target.closest('.panel')) return; e.preventDefault(); 
        targetCamDistance -= e.deltaY * 5.0; 
        targetCamDistance = Math.max(CONFIG.MAX_ZOOM, targetCamDistance);
    }, { passive: false });

    let initialPinchDistance = null; let startZoomDistance = 0;
    const getPinchDistance = (touches) => { return Math.sqrt((touches[0].clientX - touches[1].clientX)**2 + (touches[0].clientY - touches[1].clientY)**2); };

    const startDrag = (e) => {
        if (e.target.closest('.panel')) return;
        const currentTime = new Date().getTime();
        if (currentTime - lastTap < 300 && currentTime - lastTap > 0) { targetCamDistance = CONFIG.FINAL_DISTANCE; camTiltAngle = CONFIG.BASE_TILT; autoRotate = true; e.preventDefault(); }
        lastTap = currentTime; autoRotate = false;
        if (e.touches && e.touches.length === 2) { isDragging = false; initialPinchDistance = getPinchDistance(e.touches); startZoomDistance = targetCamDistance; return; }
        isDragging = true; lastX = e.touches ? e.touches[0].clientX : e.clientX; lastY = e.touches ? e.touches[0].clientY : e.clientY; clearTimeout(resumeTimeout);
    };

    const moveDrag = (e) => {
        if (e.target.closest('.panel')) return; if(e.cancelable) e.preventDefault();
        if (e.touches && e.touches.length === 2 && initialPinchDistance) {
            targetCamDistance = startZoomDistance + (getPinchDistance(e.touches) - initialPinchDistance) * 10.0;
            targetCamDistance = Math.max(CONFIG.MAX_ZOOM, targetCamDistance); 
            return;
        }
        if (!isDragging) return;
        const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY;
        camOrbitAngle += (cx - lastX) * 0.005; camTiltAngle = Math.max(-1.5, Math.min(1.5, camTiltAngle + (cy - lastY) * 0.005)); lastX = cx; lastY = cy;
    };

    const endDrag = () => { isDragging = false; initialPinchDistance = null; resumeTimeout = setTimeout(() => autoRotate = true, 2000); };
    btnStart.addEventListener('click', (e) => { e.stopPropagation(); triggerStart(); });
    window.addEventListener('mousedown', startDrag); window.addEventListener('mousemove', moveDrag); window.addEventListener('mouseup', endDrag); window.addEventListener('mouseleave', endDrag);
    window.addEventListener('touchstart', startDrag, { passive: false }); window.addEventListener('touchmove', moveDrag, { passive: false }); window.addEventListener('touchend', endDrag); window.addEventListener('touchcancel', endDrag);

    function animate() {
        ctx.fillStyle = 'rgba(0, 0, 5, 0.4)'; 
        ctx.fillRect(0, 0, width, height); 
        ctx.globalCompositeOperation = 'lighter';
        
        let cx = width / 2; let cy = height / 2; const time = performance.now();
        if (camShake > 0.5) { cx += (Math.random() - 0.5) * camShake; cy += (Math.random() - 0.5) * camShake; camShake *= 0.9; }
        if (isNaN(camDistance) || isNaN(targetCamDistance)) { camDistance = CONFIG.FINAL_DISTANCE; targetCamDistance = CONFIG.FINAL_DISTANCE; }
        if (autoRotate) camOrbitAngle -= currentSettings.camSpeed; 
        camDistance += (targetCamDistance - camDistance) * ((isDragging || initialPinchDistance) ? 0.2 : 0.05);

        let pulseScale = 1; let hueShift = 0; let lightShift = 0;
        if (currentState >= STATE.LOVE_FORM) {
            const beatVal = Math.sin(time * 0.003); pulseScale = 1 + ((beatVal + 1) / 2 * 0.05); hueShift = ((beatVal + 1) / 2) * -20; lightShift = ((beatVal + 1) / 2) * 10;
        }

        if (currentState === STATE.SORTING) {
            for(let k=0; k<currentSettings.sortSpeed; k++) {
                if (sortIndex < particles.length) { particles[sortIndex].active = true; sortIndex++; }
                else { 
                    currentState = STATE.LOVE_APPROACH; stateStartTime = time; 
                    SoundFX.playSwoosh(5000); 
                }
            }
        }
        
        if (currentState === STATE.LOVE_APPROACH && (time - stateStartTime > 5000)) currentState = STATE.LOVE_EXPLODE;
        
        if (currentState === STATE.LOVE_EXPLODE) {
            camShake = 40; SoundFX.playImpact(); 
            textParticles.forEach(p => { p.vx = (Math.random() - 0.5) * 120; p.vy = (Math.random() - 0.5) * 120; p.vz = (Math.random() - 0.5) * 120; });
            
            setTimeout(() => { 
                currentState = STATE.LOVE_FORM; 
                setTimeout(() => { 
                    currentState = STATE.DONE; 
                    SoundFX.startHeartbeat();
                }, 2000);
            }, 2000); 
            
            currentState = STATE.LOVE_WAIT; 
        }

        let r1Cos = 1, r1Sin = 0, r2Cos = 1, r2Sin = 0, dCos = 1, dSin = 0, hCos = 1, hSin = 0;
        if (currentState >= STATE.SORTING) {
            ring1Angle -= 0.002; ring2Angle -= 0.001; dustAngle -= 0.0005; heartAngle -= 0.0008; 
            r1Cos = Math.cos(ring1Angle); r1Sin = Math.sin(ring1Angle); r2Cos = Math.cos(ring2Angle); r2Sin = Math.sin(ring2Angle);
            dCos = Math.cos(dustAngle); dSin = Math.sin(dustAngle); hCos = Math.cos(heartAngle); hSin = Math.sin(heartAngle);
        }

        const processParticle = p => {
            if (currentState < STATE.COLLISION) {
                if (p.type === 'dust') {
                    p.x = 0; p.y = 0; p.z = 0; 
                } else if (currentState === STATE.STAR) {
                    const dir = p.startTeam === 'blue' ? 1 : -1;
                    p.x = (dir * CONFIG.START_X) + p.lx; p.y = p.ly; p.z = p.lz;
                } else if (currentState === STATE.APPROACH) {
                    const eased = Math.pow(Math.min(1, (time - stateStartTime) / currentSettings.approachMS), 3); 
                    const currentRadius = CONFIG.START_X * (1 - eased); const currentAngle = (1 - eased) * (Math.PI * 2 * 4.5);
                    const teamOffset = p.startTeam === 'blue' ? 0 : Math.PI;
                    p.x = Math.cos(currentAngle + teamOffset) * currentRadius + p.lx; p.y = p.ly; p.z = Math.sin(currentAngle + teamOffset) * currentRadius + p.lz;
                }
            }
            else if (currentState === STATE.COLLISION) {
                p.x += p.vx; p.y += p.vy; p.z += p.vz; 
                if (p.type !== 'dust') { 
                    p.vx *= 0.90; p.vy *= 0.90; p.vz *= 0.90; 
                } else { 
                    p.vx *= 0.98; p.vy *= 0.98; p.vz *= 0.98; 
                }
            } 
            else { 
                if (p.type === 'dust') { 
                    p.x += p.vx * 0.02; p.y += p.vy * 0.02; p.z += p.vz * 0.02; 
                }
                else if (p.active) { p.x += (p.tx - p.x) * 0.25; p.y += (p.ty - p.y) * 0.25; p.z += (p.tz - p.z) * 0.25; }
                else { p.x += p.vx * 0.1; p.y += p.vy * 0.1; p.z += p.vz * 0.1; }
            }

            let x = p.x, y = p.y, z = p.z;
            if (currentState >= STATE.SORTING) {
                if (p.type === 'ring1') { let rx = x*r1Cos - z*r1Sin; let rz = x*r1Sin + z*r1Cos; x=rx; z=rz; }
                else if (p.type === 'ring2') { let rx = x*r2Cos - z*r2Sin; let rz = x*r2Sin + z*r2Cos; x=rx; z=rz; }
                else if (p.type === 'dust') { let rx = x*dCos - z*dSin; let rz = x*dSin + z*dCos; x=rx; z=rz; }
                else if (p.type === 'heart') { let rx = x*hCos - z*hSin; let rz = x*hSin + z*hCos; x=rx; z=rz; }
            }
            renderPoint(p, x, y, z, cx, cy, pulseScale, hueShift, lightShift);
        };

        particles.forEach(processParticle);
        dustParticles.forEach(processParticle);

        if (currentState >= STATE.LOVE_APPROACH) {
            textParticles.forEach(p => {
                if (currentState === STATE.LOVE_APPROACH) {
                    const progress = Math.min(1, (time - stateStartTime) / 5000); 
                    const radius = 3000 * Math.pow(1 - progress, 2);
                    const angle = progress * Math.PI * 2 * 3;
                    
                    p.x = Math.cos(angle) * radius + p.lx;
                    p.y = Math.sin(angle) * radius + p.ly;
                    p.z = p.lz; 
                    
                } else if (currentState === STATE.LOVE_WAIT) {
                    p.x += p.vx; p.y += p.vy; p.z += p.vz; p.vx *= 0.95; p.vy *= 0.95; p.vz *= 0.95; 
                } else if (currentState >= STATE.LOVE_FORM) {
                    p.x += (p.tx - p.x) * 0.05; p.y += (p.ty - p.y) * 0.05; p.z += (p.tz - p.z) * 0.05;
                }
                let x = p.x, y = p.y, z = p.z;
                let rx = x*hCos - z*hSin; let rz = x*hSin + z*hCos; x = rx; z = rz;
                renderPoint(p, x, y, z, cx, cy, pulseScale, 0, 0);
            });
        }
        ctx.globalCompositeOperation = 'source-over'; requestAnimationFrame(animate);
    }

    function renderPoint(p, x, y, z, cx, cy, pulseScale, hueShift, lightShift) {
        if (p.type === 'dust' && currentState < STATE.COLLISION) return; 
        let tx = x * Math.cos(camOrbitAngle) - z * Math.sin(camOrbitAngle); let tz = x * Math.sin(camOrbitAngle) + z * Math.cos(camOrbitAngle); x = tx; z = tz;
        let ty = y * Math.cos(camTiltAngle) - z * Math.sin(camTiltAngle); tz = y * Math.sin(camTiltAngle) + z * Math.cos(camTiltAngle); y = ty; z = tz; z -= camDistance; 
        
        let finalScale = CONFIG.PERSPECTIVE / z;
        if (p.type === 'heart' || p.type === 'text') finalScale *= pulseScale;
        
        if (finalScale > 0) {
            let hue = p.hue, sat = p.sat, light = p.light, alpha = 1;
            if (p.type === 'text') alpha = 1.0; 
            else if (currentState < STATE.SORTING && p.type !== 'dust') { hue = p.startTeam === 'blue' ? 190 : 300; sat = '100%'; light = 70; }
            else {
                if (p.type === 'heart' && currentState >= STATE.DONE) { hue += hueShift; light += lightShift; }
                if (p.type === 'dust') alpha = Math.max(0.4, Math.min(1, finalScale * 3.0)); else alpha = 0.95;
            }
            
            ctx.fillStyle = `hsla(${hue}, ${sat}, ${light}%, ${alpha})`; 
            ctx.beginPath(); 
            ctx.arc(cx + x * finalScale, cy + y * finalScale, Math.max(0.6, p.size * finalScale), 0, Math.PI * 2); 
            ctx.fill();
        }
    }
    
    window.addEventListener('resize', () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; });
    init(); animate();
</script>
</body>
</html>
